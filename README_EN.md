# üß™ Syst√®me de R√©action üß™

## üöÄ Reaction System Project

Welcome to the mini-project **Reaction System** developed by **Ethan Nicolas** and **Dmytro Palahin** based on the research of our professor **Carlos Olarte**. This project aims to model and analyze chemical reaction systems using sequences of entities and defined reactions.

## üéØ Table of Contents

1. Introduction
2. Features
3. Installation
4. Usage

## üé¨ Introduction

This project allows modeling chemical reaction systems and verifying various logical properties on the sequences of entities generated by these systems. The main features include observing the outputs of a reaction system (RS), interacting with a process K, and verifying the production of specific entities.

## ‚ú® Features

- **üîç Observation of RS outputs** under a given input sequence.
- **üîÅ Interaction with a process K** to observe the behavior of an RS.
- **‚öõÔ∏è Verification of the production of specific entities** in an RS during interaction with a process K.
- **‚úÖ Manipulation of logical formulas** to verify complex properties on the sequences of entities.

## üöß Installation

To install and run this project, follow the steps below:

1. Clone the repository:

    ```bash
    git clone https://github.com/ethancls/ReactionsSystems.git
    cd ReactionsSystems
    ```

2. Ensure you have GHC (Glasgow Haskell Compiler) and GHCI installed. You can install it via [Haskell Platform](https://www.haskell.org/platform/).

3. Compile the project:

    ```bash
    ghci
    :l src/hsreact.hs
    ```

4. Run the program:

    ```bash
    hsreact
    ```

## üìã Usage

### 1. Observe the output of an RS with a given list of input sequences

To observe the output of a reaction system under a given list of input sequences, use `verifSysteme`. For example:

```haskell
verifSysteme betaSequence alphaSystem
```

where **alphaSystem** is

```haskell
alphaSystem :: [Reaction]
alphaSystem =
    [ Reaction ["egf"] ["e", "p"] ["erbb1"]
    , Reaction ["egf"] [] ["erk12"]
    , Reaction ["erk12"] [] ["p70s6k"]
    , Reaction ["a"] ["b"] ["c"]
    , Reaction ["c"] ["a"] ["d"]
    ]
```

and **betaSequence** is

```haskell
betaSequence :: [Sequence]
betaSequence =
    [ ["egf"]
    , ["egf", "e"]
    , ["erk12", "egf"]
    , ["a", "c"]
    ]
```

You get the unique possible application of the different reactions to the sequence system.

```haskell
[["erbb1","erk12"],["erk12"],["p70s6k","erbb1","erk12"],["c"]]
```

### 2. Observe the output of an RS from a base entity and observe the chain reaction

To observe the output of a reaction system under a given input and have the process until termination, use the function `reacChaine`. For example:

```haskell
reacChaine ["egf"] alphaSystem
```

where **alphaSystem** is

```haskell
alphaSystem :: [Reaction]
alphaSystem =
    [ Reaction ["egf"] ["e", "p"] ["erbb1"]
    , Reaction ["egf"] [] ["erk12"]
    , Reaction ["erk12"] [] ["p70s6k"]
    , Reaction ["a"] ["b"] ["c"]
    , Reaction ["c"] ["a"] ["d"]
    ]
```

and you get this result:

```haskell
[["erbb1","erk12"],["p70s6k"]]
```

Here, `egf` produces `errb1` and `erk12` in the first pass, then we reapply the RS to these outputs and get `p70s6k`. So with a starting entity, we have the list of all possible entities that can be produced. It is a deterministic process.

### 3. Observe the behavior of an RS during interaction with a process K

To observe the behavior of an RS during interaction with a process K, use the function `recK`. For example:

```haskell
recK [["egf"]] alphaSystem
```

The `recK` function gives us the progress of an RS in interaction with a process K, i.e., a list of entities, "generators". These entities are modifiable in the `generateur.txt` file under the **data** folder. We put the entities between `,` if they are in the same `C_i` otherwise we place a `;`. For example:

`recK ((a,b).X c.X) is written a,b;c`

#### üîß Function `recK`

The `recK` function is a recursive function that takes as input a list of generators (`[Generateur]`) and a list of reactions (`[Reaction]`). It returns an IO action that produces a list of lists of sequences (`IO [[Sequence]]`).

#### Arguments

- **`generateur`**: A list of generators (`[Generateur]`).
- **`reactions`**: A list of reactions (`[Reaction]`).

#### Functioning

1. **Initial call**:
   - `recK` calls the auxiliary function `recKAux` with the initial arguments, an initial depth of `1`, a list containing an empty list `[[]]` as the previous result, and an empty list `[]` as the accumulator.

2. **Auxiliary function `recKAux`**:
   - **Arguments**:
     - `generateur`: The list of generators.
     - `reactions`: The list of reactions.
     - `currentDepth`: The current depth of the recursion.
     - `previousRes`: The previous output.
     - `acc`: The sequence accumulator.

   - **Steps**:
     1. **Display the current depth**:

        ```haskell
        putStrLn $ "Depth " ++ show currentDepth ++ ": \n"
        ```

     2. **Display the input sequences**:

        ```haskell
        putStrLn $ "   > Input  :" ++ show previousRes
        ```

     3. **Apply the reactions**:
        - `verifSysteme` is called to apply the reactions to the previous sequences.

        ```haskell
        let currentResTemp = verifSysteme previousRes reactions
        ```

     4. **Display the temporary output sequences**:

        ```haskell
        putStrLn $ "   > Output :" ++ show currentResTemp
        ```

     5. **Generate new sequences**:
        - New sequences are generated by combining each generator with each resulting sequence, this is where recursion is applied in a way since it allows creating all possible combinations of generating entities.

        ```haskell
        let currentRes = [g ++ res | res <- currentResTemp, g <- generateur]
        ```

     6. **Display the new leaves**:

        ```haskell
        putStrLn $ "   > Leafs  :" ++ show currentRes
        ```

     7. **Update the accumulator**:
        - The new sequences are added to the accumulator after removing duplicates (if an entity is present, we already have a path to it, so no need for a second path)

        ```haskell
        let newAcc = if supDoublons acc currentRes == [] then acc else acc ++ [supDoublons acc currentRes]
        ```

     8. **Display the updated accumulator**:

        ```haskell
        putStrLn $ "   > Res    :" ++ show newAcc
        putStrLn "\n"
        ```

     9. **Check for stabilization**:
        - If the accumulator has not changed, the system is considered stabilized, and the current depth is displayed; otherwise, recursion is applied.

        ```haskell
        if acc == newAcc
          then do
            putStrLn ("####### System stabilization at depth: " ++ show currentDepth)
            return acc
          else recKAux generateur reactions (currentDepth + 1) currentRes newAcc
        ```

Suppose you have a list of generators and reactions. The [`recK`] function will apply these reactions recursively to the generated sequences until the system stabilizes, i.e., the accumulator no longer changes. The result of this function can therefore be infinite if the system does not stabilize, but reaction systems being finite, the accumulation of new entities will be finite, leading to system stabilization (no new entities are created).

### 3. Check if a given entity is produced in an RS during interaction with a process K

To check if a given entity is produced in an RS during interaction with a process K, use the `recK` function and then `presenceEntite`, which will return a Boolean. For example,

```haskell
result <- recK [["a", "b", "c"], ["c", "a", "d"]] alphaSystem
presenceEntite "a" result
```

Gives:

```haskell
ghci> result <- recK [["a", "b", "c"], ["c", "a", "d"]] alphaSystem
Depth 1: 

   > Input  :[[]]
   > Output :[[]]
   > Leafs  :[["a","b","c"],["c","a","d"]]
   > Res    :[[["a","b","c"],["c","a","d"]]]


Depth 2: 

   > Input  :[["a","b","c"],["c","a","d"]]
   > Output :[[],["c"]]
   > Leafs  :[["a","b","c"],["c","a","d"],["a","b","c","c"],["c","a","d","c"]]
   > Res    :[[["a","b","c"],["c","a","d"]],[["a","b","c","c"],["c","a","d","c"]]]


Depth 3: 

   > Input  :[["a","b","c"],["c","a","d"],["a","b","c","c"],["c","a","d","c"]]
   > Output :[[],["c"],[],["c"]]
   > Leafs  :[["a","b","c"],["c","a","d"],["a","b","c","c"],["c","a","d","c"],["a","b","c"],["c","a","d"],["a","b","c","c"],["c","a","d","c"]]
   > Res    :[[["a","b","c"],["c","a","d"]],[["a","b","c","c"],["c","a","d","c"]]]


####### System stabilization at depth: 3
ghci> presenceEntite "a" result
True
```

### 4. Check if the RS stabilizes

To check if the reaction system stabilizes, i.e., if there is a cycle where a state is visited infinitely many times, you can use the `recK` function. And you can see at which step our system stabilizes. See 3. to observe stabilization. Depth 3 does not bring any new entities, so the system stabilizes.

### 5. Results with other data

To use the data provided by our professor **Carlos Olarte**, simply use the main function:

```haskell
hsreact
```

You will then have the option to choose from larger data sets.

We conducted our tests based on page 5 of the article [ccReact: a Rewriting Framework for the Formal Analysis of Reaction Systems](./paper.pdf) and the `cases-studies` files of the [ccReact](https://github.com/carlosolarte/ccReact) system available on GitHub.

For the short-term files, we used the stimuli **egf**, **hrg**, and drugs **e**, **p**, **t**. We tested all combinations of stimuli and drugs (**empty** as well) and obtained the same results (in **generateur.txt**, enter the combination, for example, **"egf,hrg,e,t"** and test on all **short-term** files).
For the **long-term**, use the stimulus **"s"** and add the drugs in the same way.

### 6. Propositional Language

To extend our system, we have implemented a propositional language allowing formulating hypotheses and tests on the entities produced within the reaction systems.

The propositions `Phi` allow verifying propositions in the sequences produced.

#### Definition of Phi

A `Phi` expression can be a variable (representing an entity), a negation, a conjunction, or a disjunction. Here is how the formulas are defined:

```haskell
data Phi = Var Entities | Not Phi | And Phi Phi | Or Phi Phi
    deriving (Show, Eq)
```

**Var** represents an entity. We can create logical expressions from these variables. For example, to express that an entity egf is present and another entity erk12 is not, we use the following Phi expression:

```haskell
let phi = And (Var "egf") (Not (Var "erk12"))
```

#### Logical Operators

We have also implemented functions to verify logical properties on the sequences generated by the reaction systems.

Here are some examples of operators used to test properties:

```haskell
   ‚Ä¢ eventually (‚óáœÜ) -- diamond phi: checks if there is a state where an entity is present.
   ‚Ä¢ always (‚ñ°œÜ) -- box phi: checks if an entity is present in all states.
   ‚Ä¢ untilP (œÜ1 U œÜ2): checks if œÜ1 is true until œÜ2 becomes true.
```

#### Example of using the propositional language

Here is an example of verifying a proposition on the sequences generated by recK:

```haskell
let phi = And (Var "egf") (Not (Var "erk12"))
print $ eventually phi result -- Checks if there is a state where "egf" is present and "erk12" is absent on the result of the recK function
```

To use in the program, modify the `phi.txt` file in the `data` folder. This proposition will be tested with all available operators (‚óáœÜ, ‚ñ°œÜ). For œÜ1 U œÜ2, in the `hsreact` function in the Haskell source file, you can modify line **417** `print $ untilP (parsePhi "egf") (parsePhi "p") result` by replacing egf and p with other Phi propositions.

Regarding **Q.6**, the combination **‚óá‚ñ°e** and **‚ñ°‚óáe** respectively represent that there is a state in the sequence where, from that state, the property e is always true, and the second means that for each state in the sequence, there is a future state where the property e is true.

## üñåÔ∏è Conclusion

In conclusion, this project represents a significant advancement in the modeling and analysis of chemical reaction systems. It offers powerful tools for logical verification and visualization of generated sequences while remaining flexible and extensible to meet future needs. We hope this project will serve as a basis for future research and practical applications in this fascinating field.
